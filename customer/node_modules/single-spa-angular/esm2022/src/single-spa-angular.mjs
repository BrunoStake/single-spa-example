import { getContainerElementAndSetTemplate } from 'single-spa-angular/internals';
import { SingleSpaPlatformLocation } from './extra-providers';
const defaultOptions = {
    // Required options that will be set by the library consumer.
    NgZone: null,
    bootstrapFunction: null,
    template: null,
    // Optional options
    Router: undefined,
    domElementGetter: undefined,
    updateFunction: () => Promise.resolve(),
    bootstrappedNgModuleRefOrAppRef: null,
};
const NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;
export function singleSpaAngular(userOptions) {
    if (NG_DEV_MODE && typeof userOptions !== 'object') {
        throw Error('single-spa-angular requires a configuration object');
    }
    const options = {
        ...defaultOptions,
        ...userOptions,
    };
    if (NG_DEV_MODE && typeof options.bootstrapFunction !== 'function') {
        throw Error('single-spa-angular must be passed an options.bootstrapFunction');
    }
    if (NG_DEV_MODE && typeof options.template !== 'string') {
        throw Error('single-spa-angular must be passed options.template string');
    }
    if (NG_DEV_MODE && !options.NgZone) {
        throw Error(`single-spa-angular must be passed the NgZone option`);
    }
    if (NG_DEV_MODE && options.Router && !options.NavigationStart) {
        // We call `console.warn` except of throwing `new Error()` since this will not
        // be a breaking change.
        console.warn(`single-spa-angular must be passed the NavigationStart option`);
    }
    return {
        bootstrap: bootstrap.bind(null, options),
        mount: mount.bind(null, options),
        unmount: unmount.bind(null, options),
        update: options.updateFunction,
    };
}
async function bootstrap(options) {
    // Angular provides an opportunity to develop `zone-less` application, where developers
    // have to trigger change detection manually.
    // See https://angular.io/guide/zone#noopzone
    if (options.NgZone === 'noop') {
        return;
    }
    // Note that we have to make it a noop function because it's a static property and not
    // an instance property. We're unable to configure it for multiple apps when dependencies
    // are shared and reference the same `NgZone` class. We can't determine where this function
    // is being executed or under which application, making it difficult to assert whether this
    // app is running under its zone.
    options.NgZone.assertInAngularZone = () => { };
    options.NgZone.assertNotInAngularZone = () => { };
    options.routingEventListener = () => {
        options.bootstrappedNgZone.run(() => {
            // See https://github.com/single-spa/single-spa-angular/issues/86
            // Zone is unaware of the single-spa navigation change and so Angular change detection doesn't work
            // unless we tell Zone that something happened
        });
    };
}
async function mount(options, props) {
    getContainerElementAndSetTemplate(options, props);
    const bootstrapPromise = options.bootstrapFunction(props);
    if (NG_DEV_MODE && !(bootstrapPromise instanceof Promise)) {
        throw Error(`single-spa-angular: the options.bootstrapFunction must return a promise, but instead returned a '${typeof bootstrapPromise}' that is not a Promise`);
    }
    const ngModuleRefOrAppRef = await bootstrapPromise;
    if (NG_DEV_MODE) {
        if (!ngModuleRefOrAppRef || typeof ngModuleRefOrAppRef.destroy !== 'function') {
            throw Error(`single-spa-angular: the options.bootstrapFunction returned a promise that did not resolve with a valid Angular module or ApplicationRef. Did you call platformBrowserDynamic().bootstrapModule() correctly?`);
        }
    }
    const singleSpaPlatformLocation = ngModuleRefOrAppRef.injector.get(SingleSpaPlatformLocation, null);
    const ngZoneEnabled = options.NgZone !== 'noop';
    // The user has to provide `BrowserPlatformLocation` only if his application uses routing.
    // So if he provided `Router` but didn't provide `BrowserPlatformLocation` then we have to inform him.
    // Also `getSingleSpaExtraProviders()` function should be called only if the user doesn't use
    // `zone-less` change detection, if `NgZone` is `noop` then we can skip it.
    if (NG_DEV_MODE && ngZoneEnabled && options.Router && singleSpaPlatformLocation === null) {
        throw new Error(`
      single-spa-angular: could not retrieve extra providers from the platform injector. Did you call platformBrowserDynamic(getSingleSpaExtraProviders()).bootstrapModule()?
    `);
    }
    const bootstrappedOptions = options;
    if (ngZoneEnabled) {
        const ngZone = ngModuleRefOrAppRef.injector.get(options.NgZone);
        // `NgZone` can be enabled but routing may not be used thus `getSingleSpaExtraProviders()`
        // function was not called.
        if (singleSpaPlatformLocation !== null) {
            skipLocationChangeOnNonImperativeRoutingTriggers(ngModuleRefOrAppRef, options);
        }
        bootstrappedOptions.bootstrappedNgZone = ngZone;
        window.addEventListener('single-spa:routing-event', bootstrappedOptions.routingEventListener);
    }
    bootstrappedOptions.bootstrappedNgModuleRefOrAppRef = ngModuleRefOrAppRef;
    return ngModuleRefOrAppRef;
}
function unmount(options) {
    return Promise.resolve().then(() => {
        if (options.routingEventListener) {
            window.removeEventListener('single-spa:routing-event', options.routingEventListener);
        }
        options.bootstrappedNgModuleRefOrAppRef.destroy();
        options.bootstrappedNgModuleRefOrAppRef = null;
    });
}
function skipLocationChangeOnNonImperativeRoutingTriggers(ngModuleRefOrAppRef, options) {
    if (!options.NavigationStart) {
        // As discussed we don't do anything right now if the developer doesn't provide
        // `options.NavigationStart` since this might be a breaking change.
        return;
    }
    const router = ngModuleRefOrAppRef.injector.get(options.Router);
    const subscription = router.events.subscribe((event) => {
        if (event instanceof options.NavigationStart) {
            const currentNavigation = router.getCurrentNavigation();
            // This listener will be set up for each Angular application
            // that has routing capabilities.
            // We set `skipLocationChange` for each non-imperative navigation,
            // Angular router checks under the hood if it has to change
            // the browser URL or not.
            // If `skipLocationChange` is truthy then Angular router will not call
            // `setBrowserUrl()` which calls `history.replaceState()` and dispatches `popstate` event.
            if (currentNavigation.trigger !== 'imperative') {
                currentNavigation.extras.skipLocationChange = true;
                currentNavigation.extras.replaceUrl = false;
            }
        }
    });
    ngModuleRefOrAppRef.onDestroy(() => subscription.unsubscribe());
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2luZ2xlLXNwYS1hbmd1bGFyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbGlicy9zaW5nbGUtc3BhLWFuZ3VsYXIvc3JjL3NpbmdsZS1zcGEtYW5ndWxhci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFHQSxPQUFPLEVBQUUsaUNBQWlDLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUVqRixPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUc5RCxNQUFNLGNBQWMsR0FBRztJQUNyQiw2REFBNkQ7SUFDN0QsTUFBTSxFQUFFLElBQUs7SUFDYixpQkFBaUIsRUFBRSxJQUFLO0lBQ3hCLFFBQVEsRUFBRSxJQUFLO0lBQ2YsbUJBQW1CO0lBQ25CLE1BQU0sRUFBRSxTQUFTO0lBQ2pCLGdCQUFnQixFQUFFLFNBQVM7SUFDM0IsY0FBYyxFQUFFLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUU7SUFDdkMsK0JBQStCLEVBQUUsSUFBSTtDQUN0QyxDQUFDO0FBTUYsTUFBTSxXQUFXLEdBQUcsT0FBTyxTQUFTLEtBQUssV0FBVyxJQUFJLFNBQVMsQ0FBQztBQUVsRSxNQUFNLFVBQVUsZ0JBQWdCLENBQUksV0FBdUM7SUFDekUsSUFBSSxXQUFXLElBQUksT0FBTyxXQUFXLEtBQUssUUFBUSxFQUFFO1FBQ2xELE1BQU0sS0FBSyxDQUFDLG9EQUFvRCxDQUFDLENBQUM7S0FDbkU7SUFFRCxNQUFNLE9BQU8sR0FBNEI7UUFDdkMsR0FBRyxjQUFjO1FBQ2pCLEdBQUcsV0FBVztLQUNmLENBQUM7SUFFRixJQUFJLFdBQVcsSUFBSSxPQUFPLE9BQU8sQ0FBQyxpQkFBaUIsS0FBSyxVQUFVLEVBQUU7UUFDbEUsTUFBTSxLQUFLLENBQUMsZ0VBQWdFLENBQUMsQ0FBQztLQUMvRTtJQUVELElBQUksV0FBVyxJQUFJLE9BQU8sT0FBTyxDQUFDLFFBQVEsS0FBSyxRQUFRLEVBQUU7UUFDdkQsTUFBTSxLQUFLLENB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QUMsS0FBVSxFQUFFLEVBQUU7UUFDeEUsSUFBSSxLQUFLLFlBQVksT0FBTyxDQUFDLGVBQWdCLEVBQUU7WUFDN0MsTUFBTSxpQkFBaUIsR0FBRyxNQUFNLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztZQUN4RCw0REFBNEQ7WUFDNUQsaUNBQWlDO1lBQ2pDLGtFQUFrRTtZQUNsRSwyREFBMkQ7WUFDM0QsMEJBQTBCO1lBQzFCLHNFQUFzRTtZQUN0RSwwRkFBMEY7WUFDMUYsSUFBSSxpQkFBaUIsQ0FBQyxPQUFPLEtBQUssWUFBWSxFQUFFO2dCQUM5QyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsa0JBQWtCLEdBQUcsSUFBSSxDQUFDO2dCQUNuRCxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQzthQUM3QztTQUNGO0lBQ0gsQ0FBQyxDQUFDLENBQUM7SUFFSCxtQkFBbUIsQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUMsWUFBWSxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7QUFDbEUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFwcGxpY2F0aW9uUmVmLCBOZ01vZHVsZVJlZiwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IExpZmVDeWNsZXMgfSBmcm9tICdzaW5nbGUtc3BhJztcbmltcG9ydCB7IGdldENvbnRhaW5lckVsZW1lbnRBbmRTZXRUZW1wbGF0ZSB9IGZyb20gJ3NpbmdsZS1zcGEtYW5ndWxhci9pbnRlcm5hbHMnO1xuXG5pbXBvcnQgeyBTaW5nbGVTcGFQbGF0Zm9ybUxvY2F0aW9uIH0gZnJvbSAnLi9leHRyYS1wcm92aWRlcnMnO1xuaW1wb3J0IHsgU2luZ2xlU3BhQW5ndWxhck9wdGlvbnMsIEJvb3RzdHJhcHBlZFNpbmdsZVNwYUFuZ3VsYXJPcHRpb25zIH0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAvLyBSZXF1aXJlZCBvcHRpb25zIHRoYXQgd2lsbCBiZSBzZXQgYnkgdGhlIGxpYnJhcnkgY29uc3VtZXIuXG4gIE5nWm9uZTogbnVsbCEsXG4gIGJvb3RzdHJhcEZ1bmN0aW9uOiBudWxsISxcbiAgdGVtcGxhdGU6IG51bGwhLFxuICAvLyBPcHRpb25hbCBvcHRpb25zXG4gIFJvdXRlcjogdW5kZWZpbmVkLFxuICBkb21FbGVtZW50R2V0dGVyOiB1bmRlZmluZWQsIC8vIG9ubHkgb3B0aW9uYWwgaWYgeW91IHByb3ZpZGUgYSBkb21FbGVtZW50R2V0dGVyIGFzIGEgY3VzdG9tIHByb3BcbiAgdXBkYXRlRnVuY3Rpb246ICgpID0+IFByb21pc2UucmVzb2x2ZSgpLFxuICBib290c3RyYXBwZWROZ01vZHVsZVJlZk9yQXBwUmVmOiBudWxsLFxufTtcblxuLy8gVGhpcyB3aWxsIGJlIHByb3ZpZGVkIHRocm91Z2ggVGVyc2VyIGdsb2JhbCBkZWZpbml0aW9ucyBieSBBbmd1bGFyIENMSS4gVGhpcyB3aWxsXG4vLyBoZWxwIHRvIHRyZWUtc2hha2UgYXdheSB0aGUgY29kZSB1bm5lZWRlZCBmb3IgcHJvZHVjdGlvbiBidW5kbGVzLlxuZGVjbGFyZSBjb25zdCBuZ0Rldk1vZGU6IGJvb2xlYW47XG5cbmNvbnN0IE5HX0RFVl9NT0RFID0gdHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlO1xuXG5leHBvcnQgZnVuY3Rpb24gc2luZ2xlU3BhQW5ndWxhcjxUPih1c2VyT3B0aW9uczogU2luZ2xlU3BhQW5ndWxhck9wdGlvbnM8VD4pOiBMaWZlQ3ljbGVzPFQ+IHtcbiAgaWYgKE5HX0RFVl9NT0RFICYmIHR5cGVvZiB1c2VyT3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBFcnJvcignc2luZ2xlLXNwYS1hbmd1bGFyIHJlcXVpcmVzIGEgY29uZmlndXJhdGlvbiBvYmplY3QnKTtcbiAgfVxuXG4gIGNvbnN0IG9wdGlvbnM6IFNpbmdsZVNwYUFuZ3VsYXJPcHRpb25zID0ge1xuICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgIC4uLnVzZXJPcHRpb25zLFxuICB9O1xuXG4gIGlmIChOR19ERVZfTU9ERSAmJiB0eXBlb2Ygb3B0aW9ucy5ib290c3RyYXBGdW5jdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IEVycm9yKCdzaW5nbGUtc3BhLWFuZ3VsYXIgbXVzdCBiZSBwYXNzZWQgYW4gb3B0aW9ucy5ib290c3RyYXBGdW5jdGlvbicpO1xuICB9XG5cbiAgaWYgKE5HX0RFVl9NT0RFICYmIHR5cGVvZiBvcHRpb25zLnRlbXBsYXRlICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IEVycm9yKCdzaW5nbGUtc3BhLWFuZ3VsYXIgbXVzdCBiZSBwYXNzZWQgb3B0aW9ucy50ZW1wbGF0ZSBzdHJpbmcnKTtcbiAgfVxuXG4gIGlmIChOR19ERVZfTU9ERSAmJiAhb3B0aW9ucy5OZ1pvbmUpIHtcbiAgICB0aHJvdyBFcnJvcihgc2luZ2xlLXNwYS1hbmd1bGFyIG11c3QgYmUgcGFzc2VkIHRoZSBOZ1pvbmUgb3B0aW9uYCk7XG4gIH1cblxuICBpZiAoTkdfREVWX01PREUgJiYgb3B0aW9ucy5Sb3V0ZXIgJiYgIW9wdGlvbnMuTmF2aWdhdGlvblN0YXJ0KSB7XG4gICAgLy8gV2UgY2FsbCBgY29uc29sZS53YXJuYCBleGNlcHQgb2YgdGhyb3dpbmcgYG5ldyBFcnJvcigpYCBzaW5jZSB0aGlzIHdpbGwgbm90XG4gICAgLy8gYmUgYSBicmVha2luZyBjaGFuZ2UuXG4gICAgY29uc29sZS53YXJuKGBzaW5nbGUtc3BhLWFuZ3VsYXIgbXVzdCBiZSBwYXNzZWQgdGhlIE5hdmlnYXRpb25TdGFydCBvcHRpb25gKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYm9vdHN0cmFwOiBib290c3RyYXAuYmluZChudWxsLCBvcHRpb25zIGFzIEJvb3RzdHJhcHBlZFNpbmdsZVNwYUFuZ3VsYXJPcHRpb25zKSxcbiAgICBtb3VudDogbW91bnQuYmluZChudWxsLCBvcHRpb25zKSxcbiAgICB1bm1vdW50OiB1bm1vdW50LmJpbmQobnVsbCwgb3B0aW9ucyBhcyBCb290c3RyYXBwZWRTaW5nbGVTcGFBbmd1bGFyT3B0aW9ucyksXG4gICAgdXBkYXRlOiBvcHRpb25zLnVwZGF0ZUZ1bmN0aW9uLFxuICB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBib290c3RyYXAob3B0aW9uczogQm9vdHN0cmFwcGVkU2luZ2xlU3BhQW5ndWxhck9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgLy8gQW5ndWxhciBwcm92aWRlcyBhbiBvcHBvcnR1bml0eSB0byBkZXZlbG9wIGB6b25lLWxlc3NgIGFwcGxpY2F0aW9uLCB3aGVyZSBkZXZlbG9wZXJzXG4gIC8vIGhhdmUgdG8gdHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9uIG1hbnVhbGx5LlxuICAvLyBTZWUgaHR0cHM6Ly9hbmd1bGFyLmlvL2d1aWRlL3pvbmUjbm9vcHpvbmVcbiAgaWYgKG9wdGlvbnMuTmdab25lID09PSAnbm9vcCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBOb3RlIHRoYXQgd2UgaGF2ZSB0byBtYWtlIGl0IGEgbm9vcCBmdW5jdGlvbiBiZWNhdXNlIGl0J3MgYSBzdGF0aWMgcHJvcGVydHkgYW5kIG5vdFxuICAvLyBhbiBpbnN0YW5jZSBwcm9wZXJ0eS4gV2UncmUgdW5hYmxlIHRvIGNvbmZpZ3VyZSBpdCBmb3IgbXVsdGlwbGUgYXBwcyB3aGVuIGRlcGVuZGVuY2llc1xuICAvLyBhcmUgc2hhcmVkIGFuZCByZWZlcmVuY2UgdGhlIHNhbWUgYE5nWm9uZWAgY2xhc3MuIFdlIGNhbid0IGRldGVybWluZSB3aGVyZSB0aGlzIGZ1bmN0aW9uXG4gIC8vIGlzIGJlaW5nIGV4ZWN1dGVkIG9yIHVuZGVyIHdoaWNoIGFwcGxpY2F0aW9uLCBtYWtpbmcgaXQgZGlmZmljdWx0IHRvIGFzc2VydCB3aGV0aGVyIHRoaXNcbiAgLy8gYXBwIGlzIHJ1bm5pbmcgdW5kZXIgaXRzIHpvbmUuXG4gIG9wdGlvbnMuTmdab25lLmFzc2VydEluQW5ndWxhclpvbmUgPSAoKSA9PiB7fTtcbiAgb3B0aW9ucy5OZ1pvbmUuYXNzZXJ0Tm90SW5Bbmd1bGFyWm9uZSA9ICgpID0+IHt9O1xuXG4gIG9wdGlvbnMucm91dGluZ0V2ZW50TGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgb3B0aW9ucy5ib290c3RyYXBwZWROZ1pvbmUhLnJ1bigoKSA9PiB7XG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3NpbmdsZS1zcGEvc2luZ2xlLXNwYS1hbmd1bGFyL2lzc3Vlcy84NlxuICAgICAgLy8gWm9uZSBpcyB1bmF3YXJlIG9mIHRoZSBzaW5nbGUtc3BhIG5hdmlnYXRpb24gY2hhbmdlIGFuZCBzbyBBbmd1bGFyIGNoYW5nZSBkZXRlY3Rpb24gZG9lc24ndCB3b3JrXG4gICAgICAvLyB1bmxlc3Mgd2UgdGVsbCBab25lIHRoYXQgc29tZXRoaW5nIGhhcHBlbmVkXG4gICAgfSk7XG4gIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG1vdW50KFxuICBvcHRpb25zOiBTaW5nbGVTcGFBbmd1bGFyT3B0aW9ucyxcbiAgcHJvcHM6IGFueSxcbik6IFByb21pc2U8TmdNb2R1bGVSZWY8YW55PiB8IEFwcGxpY2F0aW9uUmVmPiB7XG4gIGdldENvbnRhaW5lckVsZW1lbnRBbmRTZXRUZW1wbGF0ZShvcHRpb25zLCBwcm9wcyk7XG5cbiAgY29uc3QgYm9vdHN0cmFwUHJvbWlzZSA9IG9wdGlvbnMuYm9vdHN0cmFwRnVuY3Rpb24ocHJvcHMpO1xuXG4gIGlmIChOR19ERVZfTU9ERSAmJiAhKGJvb3RzdHJhcFByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgIHRocm93IEVycm9yKFxuICAgICAgYHNpbmdsZS1zcGEtYW5ndWxhcjogdGhlIG9wdGlvbnMuYm9vdHN0cmFwRnVuY3Rpb24gbXVzdCByZXR1cm4gYSBwcm9taXNlLCBidXQgaW5zdGVhZCByZXR1cm5lZCBhICcke3R5cGVvZiBib290c3RyYXBQcm9taXNlfScgdGhhdCBpcyBub3QgYSBQcm9taXNlYCxcbiAgICApO1xuICB9XG5cbiAgY29uc3QgbmdNb2R1bGVSZWZPckFwcFJlZjogTmdNb2R1bGVSZWY8YW55PiB8IEFwcGxpY2F0aW9uUmVmID0gYXdhaXQgYm9vdHN0cmFwUHJvbWlzZTtcblxuICBpZiAoTkdfREVWX01PREUpIHtcbiAgICBpZiAoIW5nTW9kdWxlUmVmT3JBcHBSZWYgfHwgdHlwZW9mIG5nTW9kdWxlUmVmT3JBcHBSZWYuZGVzdHJveSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIGBzaW5nbGUtc3BhLWFuZ3VsYXI6IHRoZSBvcHRpb25zLmJvb3RzdHJhcEZ1bmN0aW9uIHJldHVybmVkIGEgcHJvbWlzZSB0aGF0IGRpZCBub3QgcmVzb2x2ZSB3aXRoIGEgdmFsaWQgQW5ndWxhciBtb2R1bGUgb3IgQXBwbGljYXRpb25SZWYuIERpZCB5b3UgY2FsbCBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKCkgY29ycmVjdGx5P2AsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHNpbmdsZVNwYVBsYXRmb3JtTG9jYXRpb246IFNpbmdsZVNwYVBsYXRmb3JtTG9jYXRpb24gfCBudWxsID1cbiAgICBuZ01vZHVsZVJlZk9yQXBwUmVmLmluamVjdG9yLmdldChTaW5nbGVTcGFQbGF0Zm9ybUxvY2F0aW9uLCBudWxsKTtcblxuICBjb25zdCBuZ1pvbmVFbmFibGVkID0gb3B0aW9ucy5OZ1pvbmUgIT09ICdub29wJztcblxuICAvLyBUaGUgdXNlciBoYXMgdG8gcHJvdmlkZSBgQnJvd3NlclBsYXRmb3JtTG9jYXRpb25gIG9ubHkgaWYgaGlzIGFwcGxpY2F0aW9uIHVzZXMgcm91dGluZy5cbiAgLy8gU28gaWYgaGUgcHJvdmlkZWQgYFJvdXRlcmAgYnV0IGRpZG4ndCBwcm92aWRlIGBCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbmAgdGhlbiB3ZSBoYXZlIHRvIGluZm9ybSBoaW0uXG4gIC8vIEFsc28gYGdldFNpbmdsZVNwYUV4dHJhUHJvdmlkZXJzKClgIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgb25seSBpZiB0aGUgdXNlciBkb2Vzbid0IHVzZVxuICAvLyBgem9uZS1sZXNzYCBjaGFuZ2UgZGV0ZWN0aW9uLCBpZiBgTmdab25lYCBpcyBgbm9vcGAgdGhlbiB3ZSBjYW4gc2tpcCBpdC5cbiAgaWYgKE5HX0RFVl9NT0RFICYmIG5nWm9uZUVuYWJsZWQgJiYgb3B0aW9ucy5Sb3V0ZXIgJiYgc2luZ2xlU3BhUGxhdGZvcm1Mb2NhdGlvbiA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXG4gICAgICBzaW5nbGUtc3BhLWFuZ3VsYXI6IGNvdWxkIG5vdCByZXRyaWV2ZSBleHRyYSBwcm92aWRlcnMgZnJvbSB0aGUgcGxhdGZvcm0gaW5qZWN0b3IuIERpZCB5b3UgY2FsbCBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKGdldFNpbmdsZVNwYUV4dHJhUHJvdmlkZXJzKCkpLmJvb3RzdHJhcE1vZHVsZSgpP1xuICAgIGApO1xuICB9XG5cbiAgY29uc3QgYm9vdHN0cmFwcGVkT3B0aW9ucyA9IG9wdGlvbnMgYXMgQm9vdHN0cmFwcGVkU2luZ2xlU3BhQW5ndWxhck9wdGlvbnM7XG5cbiAgaWYgKG5nWm9uZUVuYWJsZWQpIHtcbiAgICBjb25zdCBuZ1pvbmU6IE5nWm9uZSA9IG5nTW9kdWxlUmVmT3JBcHBSZWYuaW5qZWN0b3IuZ2V0KG9wdGlvbnMuTmdab25lKTtcblxuICAgIC8vIGBOZ1pvbmVgIGNhbiBiZSBlbmFibGVkIGJ1dCByb3V0aW5nIG1heSBub3QgYmUgdXNlZCB0aHVzIGBnZXRTaW5nbGVTcGFFeHRyYVByb3ZpZGVycygpYFxuICAgIC8vIGZ1bmN0aW9uIHdhcyBub3QgY2FsbGVkLlxuICAgIGlmIChzaW5nbGVTcGFQbGF0Zm9ybUxvY2F0aW9uICE9PSBudWxsKSB7XG4gICAgICBza2lwTG9jYXRpb25DaGFuZ2VPbk5vbkltcGVyYXRpdmVSb3V0aW5nVHJpZ2dlcnMobmdNb2R1bGVSZWZPckFwcFJlZiwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgYm9vdHN0cmFwcGVkT3B0aW9ucy5ib290c3RyYXBwZWROZ1pvbmUgPSBuZ1pvbmU7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3NpbmdsZS1zcGE6cm91dGluZy1ldmVudCcsIGJvb3RzdHJhcHBlZE9wdGlvbnMucm91dGluZ0V2ZW50TGlzdGVuZXIhKTtcbiAgfVxuXG4gIGJvb3RzdHJhcHBlZE9wdGlvbnMuYm9vdHN0cmFwcGVkTmdNb2R1bGVSZWZPckFwcFJlZiA9IG5nTW9kdWxlUmVmT3JBcHBSZWY7XG4gIHJldHVybiBuZ01vZHVsZVJlZk9yQXBwUmVmO1xufVxuXG5mdW5jdGlvbiB1bm1vdW50KG9wdGlvbnM6IEJvb3RzdHJhcHBlZFNpbmdsZVNwYUFuZ3VsYXJPcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICBpZiAob3B0aW9ucy5yb3V0aW5nRXZlbnRMaXN0ZW5lcikge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NpbmdsZS1zcGE6cm91dGluZy1ldmVudCcsIG9wdGlvbnMucm91dGluZ0V2ZW50TGlzdGVuZXIpO1xuICAgIH1cblxuICAgIG9wdGlvbnMuYm9vdHN0cmFwcGVkTmdNb2R1bGVSZWZPckFwcFJlZiEuZGVzdHJveSgpO1xuICAgIG9wdGlvbnMuYm9vdHN0cmFwcGVkTmdNb2R1bGVSZWZPckFwcFJlZiA9IG51bGw7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBza2lwTG9jYXRpb25DaGFuZ2VPbk5vbkltcGVyYXRpdmVSb3V0aW5nVHJpZ2dlcnMoXG4gIG5nTW9kdWxlUmVmT3JBcHBSZWY6IE5nTW9kdWxlUmVmPGFueT4gfCBBcHBsaWNhdGlvblJlZixcbiAgb3B0aW9uczogU2luZ2xlU3BhQW5ndWxhck9wdGlvbnMsXG4pOiB2b2lkIHtcbiAgaWYgKCFvcHRpb25zLk5hdmlnYXRpb25TdGFydCkge1xuICAgIC8vIEFzIGRpc2N1c3NlZCB3ZSBkb24ndCBkbyBhbnl0aGluZyByaWdodCBub3cgaWYgdGhlIGRldmVsb3BlciBkb2Vzbid0IHByb3ZpZGVcbiAgICAvLyBgb3B0aW9ucy5OYXZpZ2F0aW9uU3RhcnRgIHNpbmNlIHRoaXMgbWlnaHQgYmUgYSBicmVha2luZyBjaGFuZ2UuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgcm91dGVyID0gbmdNb2R1bGVSZWZPckFwcFJlZi5pbmplY3Rvci5nZXQob3B0aW9ucy5Sb3V0ZXIpO1xuICBjb25zdCBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbiA9IHJvdXRlci5ldmVudHMuc3Vic2NyaWJlKChldmVudDogYW55KSA9PiB7XG4gICAgaWYgKGV2ZW50IGluc3RhbmNlb2Ygb3B0aW9ucy5OYXZpZ2F0aW9uU3RhcnQhKSB7XG4gICAgICBjb25zdCBjdXJyZW50TmF2aWdhdGlvbiA9IHJvdXRlci5nZXRDdXJyZW50TmF2aWdhdGlvbigpO1xuICAgICAgLy8gVGhpcyBsaXN0ZW5lciB3aWxsIGJlIHNldCB1cCBmb3IgZWFjaCBBbmd1bGFyIGFwcGxpY2F0aW9uXG4gICAgICAvLyB0aGF0IGhhcyByb3V0aW5nIGNhcGFiaWxpdGllcy5cbiAgICAgIC8vIFdlIHNldCBgc2tpcExvY2F0aW9uQ2hhbmdlYCBmb3IgZWFjaCBub24taW1wZXJhdGl2ZSBuYXZpZ2F0aW9uLFxuICAgICAgLy8gQW5ndWxhciByb3V0ZXIgY2hlY2tzIHVuZGVyIHRoZSBob29kIGlmIGl0IGhhcyB0byBjaGFuZ2VcbiAgICAgIC8vIHRoZSBicm93c2VyIFVSTCBvciBub3QuXG4gICAgICAvLyBJZiBgc2tpcExvY2F0aW9uQ2hhbmdlYCBpcyB0cnV0aHkgdGhlbiBBbmd1bGFyIHJvdXRlciB3aWxsIG5vdCBjYWxsXG4gICAgICAvLyBgc2V0QnJvd3NlclVybCgpYCB3aGljaCBjYWxscyBgaGlzdG9yeS5yZXBsYWNlU3RhdGUoKWAgYW5kIGRpc3BhdGNoZXMgYHBvcHN0YXRlYCBldmVudC5cbiAgICAgIGlmIChjdXJyZW50TmF2aWdhdGlvbi50cmlnZ2VyICE9PSAnaW1wZXJhdGl2ZScpIHtcbiAgICAgICAgY3VycmVudE5hdmlnYXRpb24uZXh0cmFzLnNraXBMb2NhdGlvbkNoYW5nZSA9IHRydWU7XG4gICAgICAgIGN1cnJlbnROYXZpZ2F0aW9uLmV4dHJhcy5yZXBsYWNlVXJsID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBuZ01vZHVsZVJlZk9yQXBwUmVmLm9uRGVzdHJveSgoKSA9PiBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKSk7XG59XG4iXX0=